<!doctype html>

<html lang="en">

<head>
  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Raspberry Pi Serial COMM</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

</head>

<body>

  <main class="m-3">

    <section>

      <button id="btn_start_serial_comm" hidden class="btn btn-primary">Start Communication</button>

      <div id="div_controls" hidden>

        <button id="btn_restart_rp" class="btn btn-primary">Restart Raspberry Pi</button>

        <button id="btn_exit_rp" class="btn btn-primary">Exit Raspberry Pi</button>

        <p><small>(last 10 log messages shown)</small></p>

      </div>

    </section>

    <section>

      <p id="log" class="info"></p>

    </section>

  </main>

  <script type="text/javascript">

    class RPIDebugger {

      #line_break_transformer = class {

        #chunks;

        constructor() {

          this.#chunks = "";

        }

        transform(chunk, controller) {

          this.#chunks += chunk;

          const lines = this.#chunks.split(/\r?\n|\r|\n/g);

          this.#chunks = lines.pop();

          lines.forEach((line) => controller.enqueue(line));

        }

        flush(controller) {

          controller.enqueue(this.#chunks);

        }

      };

      #lbl_log;

      #state = { stopped: -1, running: 0, restarting: -2, unavailable: -3 };

      #btn_start_serial_comm;

      #div_controls;

      #serial_port;

      constructor() {

        this.#btn_start_serial_comm = document.getElementById("btn_start_serial_comm");

        this.#div_controls = document.getElementById("div_controls");

        this.#lbl_log = document.getElementById("log");

        this.#btn_start_serial_comm.addEventListener("click", () => { this.#btn_start_serial_comm_click(); });

        document.getElementById("btn_restart_rp").addEventListener("click", () => { this.#btn_restart_rp_click(); });

        document.getElementById("btn_exit_rp").addEventListener("click", async () => { this.#set_ui(this.#state.unavailable); await this.#write_to_COMM(/* q */113); });

        this.#set_ui(this.#state.stopped);
      }

      #set_ui(ui_state) {

        this.#lbl_log.innerHTML = "";

        switch (ui_state) {

          case this.#state.stopped: {

            this.#btn_start_serial_comm.hidden = false;

            this.#div_controls.hidden = true;

          }
            break;

          case this.#state.unavailable:
          case this.#state.restarting: {

            this.#btn_start_serial_comm.hidden = true;

            this.#div_controls.hidden = true;

          }
            break;

          case this.#state.running: {

            this.#btn_start_serial_comm.hidden = true;

            this.#div_controls.hidden = false;

          }
            break;

          default: // do nothing
        }
      }

      async #btn_start_serial_comm_click() {

        if (!("serial" in navigator)) {

          alert("Serial Communication is not supported in this browser or device.");

          this.#set_ui(this.#state.unavailable);

          return;
        }

        this.#lbl_log.innerHTML = `<small class="text-success">Starting...</small>`;

        this.#set_ui(this.#state.restarting);

        // select the first saved port
        await navigator.serial.getPorts().then((ports) => { ports.forEach((port) => { this.#serial_port = port; console.log(port.getInfo().usbVendorId); return; }); });

        // ask user if none saved
        if (!this.#serial_port) { this.#serial_port = await navigator.serial.requestPort([{ usbVendorId: 0x2E8A }]).catch(() => this.#set_ui(this.#state.stopped)); }

        await this.#serial_port.open({ baudRate: 9600 });

        this.#lbl_log.innerHTML = `<small class="text-success">Connected at 9600!</small>`;

        const textDecoder = new TextDecoderStream();

        const readableStreamClosed = this.#serial_port.readable.pipeTo(textDecoder.writable);

        const reader = textDecoder.readable.pipeThrough(new TransformStream(new this.#line_break_transformer())).getReader();

        this.#set_ui(this.#state.running);

        let data = new Array(10);

        // Listen to data coming from the serial device.
        while (true) {

          try {

            const { value, done } = await reader.read();

            if (done) {

              reader.releaseLock();

              break;
            }

            data.unshift(value);

            data.pop();
          }
          catch { break; }

          this.#lbl_log.innerHTML = "";

          data.forEach((l) => { this.#lbl_log.innerHTML += `<small class="text-info d-block my-3">${l}</small>`; });
        }

        await reader.cancel().catch(() => {/* Ignore the error */ });

        await readableStreamClosed.catch(() => { /* Ignore the error */ });

        await this.#serial_port.close();

        this.#serial_port = null;
      }

      async #write_to_COMM(c) {

        const writer = this.#serial_port.writable.getWriter();

        const data = new Uint8Array([c]); // hello

        await writer.write(data);

        // Allow the serial port to be closed later.
        await writer.releaseLock();
      }

      async #btn_restart_rp_click() {

        this.#set_ui(this.#state.restarting);

        await this.#write_to_COMM(/* r */114);

        this.#lbl_log.innerHTML = `<small class="text-info">Restarting in 2 seconds...</small>`;

        window.setTimeout(async () => { await this.#btn_start_serial_comm_click(); }, 2000);
      }
    };

    let rpi_debugger;

    window.onload = function () {

      rpi_debugger = new RPIDebugger();
    }

  </script>

</body>

</html>